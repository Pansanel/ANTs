permuted
library(ant)
tttt=ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=4)
library(ant)
tttt=ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=4)
library(ant)
tttt=ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=4)
library(ant)
library(ant)
tttt=ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=4)
tttt$permutations
ant(tttt)
library(ant)
library(ant)
library(nlme)
library(lme4)
library(DHARMa)
library(MuMIn)
library(usdm)
library(ggplot2)
library(optimx)
library(multcomp)
setwd("C:/Users/Sebastian/Google Drive/R/Mandrille/data/III")
# Data preapration ----------------------------------------------------------------------------
df=read.csv(file='all data.csv',sep=';')
df=df[, -c(58:72)]
# Change names data frame-----------------
colnames(df)=c(
"Somme.de.tps.TO..min.",
"Somme.TO..min.",
"tps.foc..min",
"tps.foc..min",
"period",
"id1",
"id2",
"directionality",
"SOMME.TO..min.",
"Tps.de.focal.total" ,
"freq.TO",
"id1.Nb.crottes.SCP",
"SCP.id1"  ,
"id1.Nb.crottes.LCP"                           ,
"id1.LCP" ,
"id2.Nb.crottes.SCP"                           ,
"id2.SCP"                                         ,
"id2.Nb.crottes.LCP"                           ,
"id2.LCP"                                         ,
"id1.sex"                                            ,
"id1.dob"                                            ,
"id1.age"                                            ,
"id1.rang"                                           ,
"id1.father"                                           ,
"id1.mother"                                           ,
"id1.child.less.6months"            ,
"id1.mother.in.grp"                       ,
"id1.father.in.grp"                      ,
"id1.matriline"                                    ,
"id1.Pkmin"                                          ,
"id1.Pkmax"                                          ,
"id1.Mkmin"                                          ,
"id1.Mkmax"                                          ,
"id1.kinship.brother.less.3.months" ,
"id1.remarque"                                       ,
"id2.sex"                                            ,
"id2.dob"                                            ,
"id2.age"                                            ,
"id2.rang"                                           ,
"id2.father"                                           ,
"id2.mother"                                           ,
"id2.child.less.6months"            ,
"id2.mother.in.grp"                       ,
"id2.father.in.grp"                      ,
"id2.matriline"                                    ,
"id2.Pkmin"                                          ,
"id2.Pkmax"                                          ,
"id2.Mkmin"                                          ,
"id2.Mkmax"                                          ,
"id2.remarque"                                       ,
"id2.kinship.brother.less.3.months" ,
"kin"                                             ,
"relatedness"                                     ,
"N.samples.corti.id1"                         ,
"id1.corti"                                 ,
"N.samples.corti.id2"                         ,
"id2.corti"
)
#deleating wek data----------------
#Erase data lower than 60 min of total of observation
df=df[df$Tps.de.focal.total>60,]
#Erase individuals that have less than one year old
df=df[df$id1.remarque=="",]
df=df[df$id2.remarque=="",]
#Convert data frame to directed data frame of interactions---------------
#' @title Convert data frames with directionality specified per dyades to a data frame where each dyade is directional
#' @param id1 an integer or a string indicating the column of first individual of the dyade.
#' @param id2 an integer or a string indicating the column of first individual of the dyade.
#' @param directionality an integer or a string indicating the column of where the information of directionality is stored.
#' @param give a string indicating the value for the 'give' term. By default is 'give'.
#' @param receive a string indicating the value for the 'receive' term. By default is 'receive'.
df.dyadic.to.directed.df=function(df,id1='id1', id2='id2',  directionality='directionality',give='give', receive='receive'){
give=give
receive=receive
col.id1=ant:::df.col.findId(df,id1)
col.id2=ant:::df.col.findId(df,id2)
col.dir=ant:::df.col.findId(df,directionality)
result=as.data.frame(matrix(ncol=ncol(df)-1,nrow=0))
name=colnames(df)[-c(col.id1,col.id2,col.dir)]
colnames(result)=c(c('actor','receiver'),name)
for(a in 1:nrow(df)){
directionality=df[,col.dir][a]
if(directionality==give){
actor=df[,col.id1][a]
receiver=df[,col.id2][a]
}
if(directionality==receive){
actor=df[,col.id2][a]
receiver=df[,col.id1][a]
}
result[nrow(result) + 1,]=c(actor,receiver,df[a,-c(col.id1,col.id2,col.dir)])
}
return(result)
}
#Extracting individuals informations--------------------
dperiod=split(df,df$period)
ldfi=lapply(dperiod, function(x){
x[,c(5,6,7,8,11)]
})
ldfi=lapply(ldfi,df.dyadic.to.directed.df,give='donne', receive='recoit', id1='id1', id2='id2', directionality='directionality')
lm=df.to.mat(ldfi,actor=1,receiver=2,weighted = 'freq.TO',num.ids = T)
# Factors of analyses
id1.fators=c("id1.sex" , "id1.age" , "id1.rang","id1.child.less.6months", "id1.mother.in.grp", "id1.father.in.grp", "id1.matriline","id1.Pkmin", "id1.Pkmax", "id1.Mkmin", "id1.Mkmax", "id1.kinship.brother.less.3.months")
id2.fators=c("id2.sex" , "id2.age" , "id2.rang","id2.child.less.6months", "id2.mother.in.grp", "id2.father.in.grp", "id2.matriline","id2.Pkmin", "id2.Pkmax", "id2.Mkmin", "id2.Mkmax", "id2.kinship.brother.less.3.months")
id1.fators=which(colnames(df) %in% id1.fators )
id2.fators=which(colnames(df) %in% id2.fators )
ldfc=lapply(dperiod, function(x){
dfc=NULL
unic=unique(c(x$id1,x$id2))
for (a in 1:nrow(x)) {
ego=x$id1[a]
if(ego %in% unic){
characteristics=x[a,id1.fators]
dfc[[a]]=cbind('id'=ego,characteristics)
unic=unic[-which(unic %in% ego)]
}
}
dfc=do.call('rbind',dfc)
unic=unique(c(x$id1,x$id2))
unic=unic[-which(unic %in% dfc$id)]
dfc2=NULL
for (a in 1:nrow(x)) {
ego=x$id2[a]
if(ego %in% unic){
characteristics=x[a,c(id2.fators)]
dfc2[[length(dfc2)+1]]=cbind('id'=ego,characteristics)
unic=unic[-which(unic %in% ego)]
}
}
dfc2=do.call('rbind',dfc2)
nrow(dfc2)
colnames(dfc2)=colnames(dfc)
dfc=rbind(dfc,dfc2)
for (a in 1:length(colnames(dfc))) {
colnames(dfc)[a]=gsub("id1.", "", colnames(dfc)[a])
}
dfc=dfc[order(dfc$id),]
return(dfc)
})
#Computing network metrics------------
ldf=met.strength(lm,df=ldfc,1)
ldf=met.degree(lm,df=ldf,1)
ldf=met.eigen(lm,df=ldf,1)
ldf=met.lp(lm,df=ldf,1)
#Converting hierarchical categories into hierarchical continuous variable---------
ldf=lapply(seq_along(ldf), function(i,ldf){
ldf[[i]]$period=as.factor(rep(i,nrow(ldf[[i]])))
return(ldf[[i]])
},ldf=ldf)
ldf=lapply(seq_along(ldf), function(i,ldf){
ldf[[i]]$rang=as.character(ldf[[i]]$rang)
ldf[[i]]$rang=ifelse(ldf[[i]]$rang=='HR',3,ldf[[i]]$rang)
ldf[[i]]$rang=ifelse(ldf[[i]]$rang=='MR',2,ldf[[i]]$rang)
ldf[[i]]$rang=ifelse(ldf[[i]]$rang=='LR',1,ldf[[i]]$rang)
return(ldf[[i]])
},ldf=ldf)
df=do.call('rbind',ldf)
df$rang=as.numeric(df$rang)
df$eigen2=log(df$eigen+0.0000001)
# Permutations----------------------------
ldf=lapply(ldf, function(x){
x$id=as.factor(x$id)
x$eigen2=x$eigen+0.00000001
return(x)
})
pldf=perm.net.nl(ldf=ldf,labels = c(2:13),rf=c(18),nperm = 100)
tttt=ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=7)
formula = log(degree)~sex*age*rang+sex*age*mother.in.grp+sex*age*father.in.grp+sex*age*Mkmin+sex*age*Pkmin+sex*age*kinship.brother.less.3.months+(1|period)+(1|id)
tttt=ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=7)
library(ant)
tttt=ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=7)
library(microbenchmarks)
install.packages("microbenchmark")
library(microbenchmarks)
library(microbenchmark)
r=microbenchmark(ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=7),ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=NULL))
args(microbenchmark)
r=microbenchmark(ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=7),ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=NULL),times=10)
summary(r)
install.packages("XR")
library(XRJulia)
findJulia(test = TRUE)
install.packages("XRJulia")
library(parallel)
f1=function(){
lapply(1:3, function(x) c(x, x^2, x^3))
}
f2=function(){
# Calculate the number of cores
no_cores <- detectCores() - 1
# Initiate cluster
cl <- makeCluster(no_cores)
parLapply(cl, 1:3,
function(exponent)
2^exponent)
stopCluster(cl)
}
microbenchmark(f1,f2)
f1=function(){
lapply(1:2000, function(x) c(x, x^2, x^3))
}
f2=function(){
# Calculate the number of cores
no_cores <- detectCores() - 1
# Initiate cluster
cl <- makeCluster(no_cores)
parLapply(cl, 1:2000,
function(exponent)
2^exponent)
stopCluster(cl)
}
microbenchmark(f1,f2)
pldf=perm.net.nl(ldf=ldf,labels = c(2:13),rf=c(18),nperm = 1000)
library(ant)
pldf=perm.net.nl(ldf=ldf,labels = c(2:13),rf=c(18),nperm = 1000)
r=microbenchmark(ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=7),ant:::stat.glmm2(ant=pldf,formula=formula,family='gaussian',ncores=NULL),times=10)
summary(tttt)
summary(r)
r
library(ant)
# Farine 2017 script --------------------------------------------------------------------------
# number of individuals
N <- 40
# Number of focals
n_focals <- 2000
# A data frame of individuals ID, sex, number of observations of an individual
ids <- data.frame(ID=1:(N),SEX=sample(c("M","F"),N,replace=TRUE))
# Generate a distribution for each of the 2000 observations (i.e. number of alters during each focals)
#Distirbution uniform
group_size <- sample(c(1:(N/2)),n_focals,replace=TRUE)
#Poisson distribution
# Create blank observation matrix:
#rows are the focals (2000) and columns the individuals (40)
obs <- matrix(0,nrow=n_focals,ncol=N)
# Function to allocate number of observations to focals
rand_vect <- function(N, M, sd = 1, pos.only = TRUE) {
vec <- rnorm(N, M/N, sd)
if (abs(sum(vec)) < 0.01) vec <- vec + 1
vec <- round(vec / sum(vec) * M)
deviation <- M - sum(vec)
for (. in seq_len(abs(deviation))) {
vec[i] <- vec[i <- sample(N, 1)] + sign(deviation)
}
if (pos.only) while (any(vec < 0)) {
negs <- vec < 0
pos  <- vec > 0
vec[negs][i] <- vec[negs][i <- sample(sum(negs), 1)] + 1
vec[pos][i]  <- vec[pos ][i <- sample(sum(pos ), 1)] - 1
}
vec
}
ids$OBS <- rand_vect(N,sum(group_size),pos.only=TRUE)
# Allocate individuals to groups, starting with males so that they end up in smaller groups
group_size.tmp <- group_size
which.males <- which(ids$SEX=="M")
for (i in which.males) {
g <- sample(1:n_focals,ids$OBS[i],prob=(group_size.tmp>0)) # select number of obs of individuals in distribution of observations
group_size.tmp[g] <- group_size.tmp[g]-1 # removing number of alters on selected focals to decrease number of alters
obs[g,i] <- 1 # adding interaction in the matrix
}
which.females <- which(ids$SEX=="F")
for (i in which.females) {
if (sum((group_size.tmp>0) < ids$OBS[i])) {
g <- sample(1:n_focals,ids$OBS[i],prob=(group_size.tmp>0),replace=TRUE)
} else {
g <- sample(1:n_focals,ids$OBS[i],prob=(group_size.tmp>0),replace=FALSE)
}
group_size.tmp[g] <- group_size.tmp[g]-1
obs[g,i] <- 1
}
# Select a focal individual from each group
focal.id <- apply(obs,1,function(x) { sample(which(x==1),1)})
# Now remove cases where individuals occur in a group for which they are focal
obs[cbind(1:n_focals,focal.id)] <- 0
# Remove some observations
# Generate probability of being observed (males=1,females=0.7)
ids$OBS_PROB <- 0.8
ids$OBS_PROB[which(ids$SEX=="M")] <- 1
# Remove observations from observations
obs.r <- obs
for (i in 1:N) {
obs.r[which(obs.r[,i] > 0),i] <- sample(c(0,1),sum(obs.r[,i]),replace=TRUE,prob=c(1-ids$OBS_PROB[i],ids$OBS_PROB[i]))
}
# Modifications control by observation time -------------------------------------------------------------------------------
# fuction to convert Farine 2017 group of observations to a data frame of interactions
grp.to.df=function(obs,focal.id){
nfocal=NULL
focal=NULL
alter=NULL
for (a in 1:nrow(obs)) {
tmp.alters=which(obs[a,]==1)
alter=append(alter,tmp.alters)
focal=append(focal,rep(focal.id[a],length(tmp.alters)))
nfocal=append(nfocal,rep(a,length(tmp.alters)))
}
df=data.frame(nfocal,focal,alter)
return(df)
}
# Original data
df=grp.to.df(obs,focal.id)
# Data with females focal deletions
df.r=grp.to.df(obs.r,focal.id)
# obtaning number of focals per individuals
nfocal=table(focal.id)
ids$nfocal.df=nfocal
ids$nfocal.df.r=nfocal
m=df.to.mat(df,2,3)
m
m
nfocal
nfocal
nfocal
n_focals
m
obs
library(ant)
?assoc.gfi
?assoc.indices
library(ant)
# Farine 2017 script --------------------------------------------------------------------------
# number of individuals
N <- 40
# Number of focals
n_focals <- 2000
# A data frame of individuals ID, sex, number of observations of an individual
ids <- data.frame(ID=1:(N),SEX=sample(c("M","F"),N,replace=TRUE))
# Generate a distribution for each of the 2000 observations (i.e. number of alters during each focals)
#Distirbution uniform
group_size <- sample(c(1:(N/2)),n_focals,replace=TRUE)
#Poisson distribution
# Create blank observation matrix:
#rows are the focals (2000) and columns the individuals (40)
obs <- matrix(0,nrow=n_focals,ncol=N)
# Function to allocate number of observations to focals
rand_vect <- function(N, M, sd = 1, pos.only = TRUE) {
vec <- rnorm(N, M/N, sd)
if (abs(sum(vec)) < 0.01) vec <- vec + 1
vec <- round(vec / sum(vec) * M)
deviation <- M - sum(vec)
for (. in seq_len(abs(deviation))) {
vec[i] <- vec[i <- sample(N, 1)] + sign(deviation)
}
if (pos.only) while (any(vec < 0)) {
negs <- vec < 0
pos  <- vec > 0
vec[negs][i] <- vec[negs][i <- sample(sum(negs), 1)] + 1
vec[pos][i]  <- vec[pos ][i <- sample(sum(pos ), 1)] - 1
}
vec
}
ids$OBS <- rand_vect(N,sum(group_size),pos.only=TRUE)
# Allocate individuals to groups, starting with males so that they end up in smaller groups
group_size.tmp <- group_size
which.males <- which(ids$SEX=="M")
for (i in which.males) {
g <- sample(1:n_focals,ids$OBS[i],prob=(group_size.tmp>0)) # select number of obs of individuals in distribution of observations
group_size.tmp[g] <- group_size.tmp[g]-1 # removing number of alters on selected focals to decrease number of alters
obs[g,i] <- 1 # adding interaction in the matrix
}
which.females <- which(ids$SEX=="F")
for (i in which.females) {
if (sum((group_size.tmp>0) < ids$OBS[i])) {
g <- sample(1:n_focals,ids$OBS[i],prob=(group_size.tmp>0),replace=TRUE)
} else {
g <- sample(1:n_focals,ids$OBS[i],prob=(group_size.tmp>0),replace=FALSE)
}
group_size.tmp[g] <- group_size.tmp[g]-1
obs[g,i] <- 1
}
# Select a focal individual from each group
focal.id <- apply(obs,1,function(x) { sample(which(x==1),1)})
# Now remove cases where individuals occur in a group for which they are focal
obs[cbind(1:n_focals,focal.id)] <- 0
# Remove some observations
# Generate probability of being observed (males=1,females=0.7)
ids$OBS_PROB <- 0.8
ids$OBS_PROB[which(ids$SEX=="M")] <- 1
# Remove observations from observations
obs.r <- obs
for (i in 1:N) {
obs.r[which(obs.r[,i] > 0),i] <- sample(c(0,1),sum(obs.r[,i]),replace=TRUE,prob=c(1-ids$OBS_PROB[i],ids$OBS_PROB[i]))
}
# Modifications control by observation time -------------------------------------------------------------------------------
# fuction to convert Farine 2017 group of observations to a data frame of interactions
grp.to.df=function(obs,focal.id){
nfocal=NULL
focal=NULL
alter=NULL
for (a in 1:nrow(obs)) {
tmp.alters=which(obs[a,]==1)
alter=append(alter,tmp.alters)
focal=append(focal,rep(focal.id[a],length(tmp.alters)))
nfocal=append(nfocal,rep(a,length(tmp.alters)))
}
df=data.frame(nfocal,focal,alter)
return(df)
}
# Original data
df=grp.to.df(obs,focal.id)
# Data with females focal deletions
df.r=grp.to.df(obs.r,focal.id)
# obtaning number of focals per individuals
nfocal=table(focal.id)
ids$nfocal.df=nfocal
ids$nfocal.df.r=nfocal
?df.to.mat
m=df.to.mat(df,2,3,tobs=nfocal,sym=T)
m.r=df.to.mat(df.r,2,3,tobs=nfocal,sym=T)
m.r.no.obs=df.to.mat(df.r,2,3)
strength=colSums(m)+rowSums(m)
strength.r=colSums(m.r)+rowSums(m.r)
strength.r.no.obs=colSums(m.r.no.obs)+rowSums(m.r.no.obs)
ids$strength=strength
ids$strength.r=strength.r
ids$strength.r.no.obs=strength.r.no.obs
# node label permutations
pdf=perm.net.nl(ids,'SEX',nperm = 1000)
test=stat.t(pdf,strength~SEX)
result=ant(test)
test.r=stat.t(pdf,strength.r~SEX)
result.r=ant(test.r)
test.r.no.obs=stat.t(pdf,strength.r.no.obs~SEX)
result.r.no.obs=ant(test.r.no.obs)
result.no.permutations=t.test(data=ids,strength.r~SEX)
result$statistics
result.r$statistics
result.r.no.obs$statistics
result.r.no.permutations
result.no.permutations
result$statistics
result.r$statistics
result.r.no.obs$statistics
m
test=stat.lm(pdf,strength~SEX)
test.r=stat.lm(pdf,strength.r~SEX)
result.r=ant(test.r)
result.r$statistics
result.r
ids
length(pdf)
pdf[[1]]
pdf[[1]]==ids
pdf[[2]]==ids
test.r=stat.lm(pdf,strength.r~SEX)
lm(data=ids,formula = strength.r~SEX)
test.r$permutations[[1]]
head(test.r$permutations)
result.r=ant(test.r)
result.r
devtools::install_github('SebastianSosa/ant')
tt.r=stat.t(pdf,strength.r~SEX)
lm.r=stat.lm(pdf,strength.r~SEX)
result.t.r=ant(tt.r)
test=stat.lm(pdf,strength~SEX)
result=ant(test)
lm.r
tt.r=stat.t(pdf,strength.r~SEX)
lm.r=stat.lm(pdf,strength.r~SEX)
result.t.r=ant(tt.r)
result.lm.r=ant(lm.r)
result.t.r$statistics
result.lm.r$statistics
tt.r=stat.t(pdf,strength.r~SEX)
lm.r=stat.lm(pdf,strength.r~SEX)
result.t.r=ant(tt.r)
result.lm.r=ant(lm.r)
result.t.r$statistics
result.lm.r$model
args(stat.glmm2)
args(ant:::stat.glmm2)
library(ant)
args(ant:::stat.glmm2)
load("C:/Users/Sebastian/Google Drive/R/Mandrille/data.RData")
f=lp~sex*age*rang+sex*age*mother.in.grp+sex*age*father.in.grp+sex*age*Mkmin+sex*age*Pkmin+sex*age*kinship.brother.less.3.months+(1|period)+(1|id)
t.lp=ant:::stat.glmm2(ant = pldf,formula = f,family = Gamma(link = "logit"), ncores = 15 )
library(parallel)
library(ant)
t.lp=ant:::stat.glmm2(ant = pldf,formula = f,family = Gamma(link = "logit"), ncores = 15 )
library(ant)
t.lp=ant:::stat.glmm2(ant = pldf,formula = f,family = Gamma(link = "logit"), ncores = 15 )
library(ant)
load("C:/Users/Sebastian/Google Drive/R/Mandrille/data.RData")
f=lp~sex*age*rang+sex*age*mother.in.grp+sex*age*father.in.grp+sex*age*Mkmin+sex*age*Pkmin+sex*age*kinship.brother.less.3.months+(1|period)+(1|id)
t.lp=ant:::stat.glmm2(ant = pldf,formula = f,family = Gamma(link = "logit"), ncores = 15 )
